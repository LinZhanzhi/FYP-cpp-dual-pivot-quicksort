import subprocess  
content = ""  
content += "#ifndef DPQS_UTILS_HPP\n"  
content += "#define DPQS_UTILS_HPP\n"  
content += "\n"  
content += "#if defined(_MSC_VER)\n"  
content += "#define FORCE_INLINE __forceinline\n"  
content += "#elif defined(__GNUC__) ^|^| defined(__clang__)\n"  
content += "#define FORCE_INLINE __attribute__((always_inline)) inline\n"  
content += "#else\n"  
content += "#define FORCE_INLINE inline\n"  
content += "#endif\n"  
content += "\n"  
content += "#if defined(__GNUC__) ^|^| defined(__clang__)\n"  
content += "#define LIKELY(x) __builtin_expect(!!(x), 1)\n"  
content += "#define UNLIKELY(x) __builtin_expect(!!(x), 0)\n"  
content += "#define PREFETCH_READ(ptr) __builtin_prefetch(ptr, 0, 3)\n"  
content += "#else\n"  
content += "#define LIKELY(x) (x)\n"  
content += "#define UNLIKELY(x) (x)\n"  
content += "#define PREFETCH_READ(ptr) ((void)0)\n"  
content += "#endif\n"  
content += "\n"  
content += "#include ^<cstring^>\n"  
content += "#include ^<cmath^>\n"  
content += "#include ^<bit^>\n"  
content += "#include ^<cstdint^>\n"  
content += "#include ^<utility^>\n"  
content += "#include ^<type_traits^>\n"  
content += "#include ^<stdexcept^>\n"  
content += "\n"  
content += "namespace dual_pivot {\n"  
content += "\n"  
content += "// Forward declarations\n"  
content += "template^<typename T^> class Sorter;\n"  
content += "\n" 
content += "/**\n"  
content += " * @brief C++ equivalent of Java's Float.floatToRawIntBits()\n"  
content += " */\n"  
content += "inline std::uint32_t floatToRawIntBits(float value) {\n"  
content += "#if __cpp_lib_bit_cast ^>= 201806L\n"  
content += "    return std::bit_cast^<std::uint32_t^>(value);\n"  
content += "#else\n"  
content += "    static_assert(sizeof(float) == sizeof(std::uint32_t), \"Float and uint32_t must have same size\");\n"  
content += "    std::uint32_t result;\n"  
content += "    std::memcpy(^&result, ^&value, sizeof(float));\n"  
content += "    return result;\n"  
content += "#endif\n"  
content += "}\n"  
content += "\n"  
content += "/**\n"  
content += " * @brief C++ equivalent of Java's Double.doubleToRawLongBits()\n"  
content += " */\n"  
content += "inline std::uint64_t doubleToRawLongBits(double value) {\n"  
content += "#if __cpp_lib_bit_cast ^>= 201806L\n"  
content += "    return std::bit_cast^<std::uint64_t^>(value);\n"  
content += "#else\n"  
content += "    static_assert(sizeof(double) == sizeof(std::uint64_t), \"Double and uint64_t must have same size\");\n"  
content += "    std::uint64_t result;\n"  
content += "    std::memcpy(^&result, ^&value, sizeof(double));\n"  
content += "    return result;\n"  
content += "#endif\n"  
content += "}\n"  
content += "\n"  
content += "/**\n"  
content += " * @brief C++ equivalent of Java's Float.intBitsToFloat()\n"  
content += " */\n"  
content += "inline float intBitsToFloat(std::uint32_t bits) {\n"  
content += "#if __cpp_lib_bit_cast ^>= 201806L\n"  
content += "    return std::bit_cast^<float^>(bits);\n"  
content += "#else\n"  
content += "    float result;\n"  
content += "    std::memcpy(^&result, ^&bits, sizeof(float));\n"  
content += "    return result;\n"  
content += "#endif\n"  
content += "}\n"  
content += "\n"  
content += "/**\n"  
content += " * @brief C++ equivalent of Java's Double.longBitsToDouble()\n"  
content += " */\n"  
content += "inline double longBitsToDouble(std::uint64_t bits) {\n"  
content += "#if __cpp_lib_bit_cast ^>= 201806L\n"  
content += "    return std::bit_cast^<double^>(bits);\n"  
content += "#else\n"  
content += "    double result;\n"  
content += "    std::memcpy(^&result, ^&bits, sizeof(double));\n"  
content += "    return result;\n"  
content += "#endif\n"  
content += "}\n"  
content += "\n" 
content += "inline bool isNegativeZero(float value) {\n"  
content += "    return value == 0.0f ^&^& floatToRawIntBits(value) == 0x80000000U;\n"  
content += "}\n"  
content += "\n"  
content += "inline bool isNegativeZero(double value) {\n"  
content += "    return value == 0.0 ^&^& doubleToRawLongBits(value) == 0x8000000000000000ULL;\n"  
content += "}\n"  
content += "\n"  
content += "inline bool isNaN(float value) {\n"  
content += "    std::uint32_t bits = floatToRawIntBits(value);\n"  
content += "    return (bits ^& 0x7F800000U) == 0x7F800000U ^&^& (bits ^& 0x007FFFFFU) != 0;\n"  
content += "}\n"  
content += "\n"  
content += "inline bool isNaN(double value) {\n"  
content += "    std::uint64_t bits = doubleToRawLongBits(value);\n"  
content += "    return (bits ^& 0x7FF0000000000000ULL) == 0x7FF0000000000000ULL ^&^& (bits ^& 0x000FFFFFFFFFFFFFULL) != 0;\n"  
content += "}\n"  
content += "\n"  
content += "inline bool isPositiveZero(float value) {\n"  
content += "    return floatToRawIntBits(value) == 0x00000000U;\n"  
content += "}\n"  
content += "\n"  
content += "inline bool isPositiveZero(double value) {\n"  
content += "    return doubleToRawLongBits(value) == 0x0000000000000000ULL;\n"  
content += "}\n"  
content += "\n"  
content += "template^<typename T^>\n"  
content += "FORCE_INLINE int findZeroPosition(T* a, int low, int high) {\n"  
content += "    while (low ^<= high) {\n"  
content += "        int middle = static_cast^<int^>(static_cast^<unsigned int^>(low + high) ^>^> 1);\n"  
content += "        if (a[middle] ^< T(0)) {\n"  
content += "            low = middle + 1;\n"  
content += "        } else {\n"  
content += "            high = middle - 1;\n"  
content += "        }\n"  
content += "    }\n"  
content += "    return low;\n"  
content += "}\n"  
content += "\n"  
content += "template^<typename T^>\n"  
content += "using SortOperation = void(*)(T* a, int low, int high);\n"  
content += "\n"  
content += "template^<typename T^>\n"  
content += "using SorterSortOperation = void(*)(Sorter^<T^>* sorter, T* a, int bits, int low, int high);\n"  
content += "\n"  
content += "template^<typename T^>\n"  
content += "using PartitionOperation = std::pair^<int, int^>(*)(T* a, int low, int high, int pivotIndex1, int pivotIndex2);\n"  
content += "\n"  
content += "template^<typename T^>\n"  
content += "FORCE_INLINE void sort_intrinsic(T* array, int low, int high, SortOperation^<T^> so) {\n"  
content += "    so(array, low, high);\n"  
content += "}\n"  
content += "\n"  
content += "template^<typename T^>\n"  
content += "FORCE_INLINE std::pair^<int, int^> partition_intrinsic(T* array, int low, int high,\n"  
content += "                                                     int pivotIndex1, int pivotIndex2,\n"  
content += "                                                     PartitionOperation^<T^> po) {\n"  
content += "    return po(array, low, high, pivotIndex1, pivotIndex2);\n"  
content += "}\n"  
content += "\n"  
content += "template^<typename T^>\n"  
content += "void checkNotNull(T* ptr, const char* msg) {\n"  
content += "    if (ptr == nullptr) {\n"  
content += "        throw std::runtime_error(msg);\n"  
content += "    }\n"  
content += "}\n"  
content += "\n"  
content += "inline int getDepth(int length) {\n"  
content += "    if (length ^<= 0) return 0;\n"  
content += "    return 3 * (int)std::floor(std::log(length));\n"  
content += "}\n"  
content += "\n"  
content += "} // namespace dual_pivot\n"  
content += "\n"  
content += "#endif // DPQS_UTILS_HPP\n"  
subprocess.run(['wsl', 'bash', '-c', 'cd FYP && cat > include/dpqs/utils.hpp'], input=content.encode('utf-8'), check=True) 
